<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CesiumJS Hartmann Grid 2D</title>
  <script src="https://unpkg.com/cesium@1.109.1/Build/Cesium/Cesium.js"></script>
  <link href="https://unpkg.com/cesium@1.109.1/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 999;
      background: white;
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    button {
      padding: 6px 10px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="askLocation()">üìç Get My Location</button>
  </div>
  <div id="cesiumContainer"></div>

  <script>
    // Set up Cesium without requiring an access token
    window.CESIUM_BASE_URL = 'https://unpkg.com/cesium@1.109.1/Build/Cesium/';

    const viewer = new Cesium.Viewer('cesiumContainer', {
      sceneMode: Cesium.SceneMode.SCENE2D,
      baseLayerPicker: false,
      animation: false,
      timeline: false,
      geocoder: false,
      homeButton: false,
      navigationHelpButton: false,
      sceneModePicker: false,
      terrainProvider: new Cesium.EllipsoidTerrainProvider()
    });

    // Hartmann grid
    const refLat = 36.709639;
    const refLon = 3.164972;
    const spacing = 2; // meters
    const metersPerDegLat = 111320;

    function metersToDegLat(m) {
      return m / metersPerDegLat;
    }

    function metersToDegLon(m, lat) {
      return m / (111320 * Math.cos(Cesium.Math.toRadians(lat)));
    }

    function drawGrid() {
      const bounds = viewer.camera.computeViewRectangle();
      if (!bounds) return;

      const latMin = Cesium.Math.toDegrees(bounds.south);
      const latMax = Cesium.Math.toDegrees(bounds.north);
      const lonMin = Cesium.Math.toDegrees(bounds.west);
      const lonMax = Cesium.Math.toDegrees(bounds.east);
      const centerLat = (latMin + latMax) / 2;

      const deltaLat = metersToDegLat(spacing);
      const deltaLon = metersToDegLon(spacing, centerLat);

      viewer.entities.removeAll();

      for (let lat = refLat; lat <= latMax; lat += deltaLat) {
        if (lat >= latMin) {
          viewer.entities.add({
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([lonMin, lat, lonMax, lat]),
              width: 0.5,
              material: Cesium.Color.GREEN
            }
          });
        }
      }

      for (let lat = refLat; lat >= latMin; lat -= deltaLat) {
        if (lat <= latMax) {
          viewer.entities.add({
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([lonMin, lat, lonMax, lat]),
              width: 0.5,
              material: Cesium.Color.GREEN
            }
          });
        }
      }

      for (let lon = refLon; lon <= lonMax; lon += deltaLon) {
        if (lon >= lonMin) {
          viewer.entities.add({
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([lon, latMin, lon, latMax]),
              width: 0.5,
              material: Cesium.Color.GREEN
            }
          });
        }
      }

      for (let lon = refLon; lon >= lonMin; lon -= deltaLon) {
        if (lon <= lonMax) {
          viewer.entities.add({
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([lon, latMin, lon, latMax]),
              width: 0.5,
              material: Cesium.Color.GREEN
            }
          });
        }
      }
    }

    viewer.scene.camera.moveEnd.addEventListener(drawGrid);
    drawGrid();

    // Real-time GPS
    let userEntity;

    function askLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            if (!userEntity) {
              userEntity = viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(lon, lat),
                point: { pixelSize: 10, color: Cesium.Color.BLUE },
                label: {
                  text: `üìç You: ${lat.toFixed(5)}, ${lon.toFixed(5)}`,
                  font: '14px sans-serif',
                  style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                  outlineWidth: 2,
                  fillColor: Cesium.Color.WHITE,
                  verticalOrigin: Cesium.VerticalOrigin.TOP,
                  pixelOffset: new Cesium.Cartesian2(0, -15)
                }
              });

              viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(lon, lat, 1000)
              });
            } else {
              userEntity.position = Cesium.Cartesian3.fromDegrees(lon, lat);
              userEntity.label.text = `üìç You: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
            }
          },
          (error) => {
            alert("Location error: " + error.message);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 5000,
            timeout: 10000
          }
        );
      } else {
        alert("Your browser doesn't support GPS.");
      }
    }
  </script>
</body>
</html>
