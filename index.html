<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hartmann Grid Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-sA+vx6kG2zZ2zLMp5e6vYtOxO1lR2HkSg+YIzP8GHr8="
    crossorigin=""
  />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .leaflet-container {
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j7kPtv8FG6Z5SjKzN2LMp0T8Q2luY7WxCkTgFoA="
    crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <script>
    const map = L.map("map").setView([36.75, 3.05], 19);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 22,
      attribution: "Â© OpenStreetMap"
    }).addTo(map);

    // ---------- GPS tracking (location.js logic, updated for mobile) ----------
    let currentLocation = null;
    let userMarker = null;
    let accuracyCircle = null;
    let watchId = null;

    function updateLocation(position) {
      currentLocation = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy
      };

      if (!userMarker) {
        userMarker = L.marker(currentLocation).addTo(map);
      } else {
        userMarker.setLatLng(currentLocation);
      }

      if (!accuracyCircle) {
        accuracyCircle = L.circle(currentLocation, {
          radius: currentLocation.accuracy,
          color: "blue",
          fillColor: "#30f",
          fillOpacity: 0.2
        }).addTo(map);
      } else {
        accuracyCircle.setLatLng(currentLocation);
        accuracyCircle.setRadius(currentLocation.accuracy);
      }

      map.setView(currentLocation, map.getZoom());
    }

    function handleGeolocationError(error) {
      console.error("Geolocation error:", error.message);
    }

    function startTracking() {
      if (navigator.geolocation) {
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
        }

        watchId = navigator.geolocation.watchPosition(
          updateLocation,
          handleGeolocationError,
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      } else {
        alert("Geolocation is not supported by this browser.");
      }
    }

    function stopTracking() {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
    }

    // ---------- Hartmann Grid Drawing (grid.js) ----------
    const gridGroup = L.layerGroup().addTo(map);
    const gridSpacingNS = 2;    // meters north-south
    const gridSpacingEW = 2.5;  // meters east-west

    function drawHartmannGrid() {
      const bounds = map.getBounds();
      const zoom = map.getZoom();
      const interval = 2 ** (20 - zoom);

      gridGroup.clearLayers();

      const startLat = bounds.getSouth();
      const endLat = bounds.getNorth();
      const startLng = bounds.getWest();
      const endLng = bounds.getEast();

      for (let lat = startLat; lat <= endLat; lat += metersToDegreesLat(gridSpacingNS)) {
        const latLine = L.polyline([[lat, startLng], [lat, endLng]], {
          color: "gray",
          weight: 1,
          opacity: 0.5
        });
        gridGroup.addLayer(latLine);
      }

      for (let lng = startLng; lng <= endLng; lng += metersToDegreesLng(gridSpacingEW, (startLat + endLat) / 2)) {
        const lngLine = L.polyline([[startLat, lng], [endLat, lng]], {
          color: "gray",
          weight: 1,
          opacity: 0.5
        });
        gridGroup.addLayer(lngLine);
      }
    }

    function metersToDegreesLat(meters) {
      return meters / 111320;
    }

    function metersToDegreesLng(meters, latitude) {
      return meters / (40075000 * Math.cos(latitude * Math.PI / 180) / 360);
    }

    map.on("moveend zoomend", drawHartmannGrid);
    drawHartmannGrid();

    // Start GPS tracking
    startTracking();
  </script>
</body>
</html>
