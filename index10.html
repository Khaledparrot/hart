<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hartmann Grid Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    button {
      padding: 6px 10px;
      font-size: 14px;
      margin: 4px;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="controls">
  <button onclick="askLocation()">üìç Get Location</button>
  <button onclick="startDrawing()">‚úèÔ∏è Draw Room</button>
  <button onclick="showIntersections()" id="showBtn" style="display:none;">üî¥ Show Intersections on Room</button>
  <button onclick="clearRoom()" id="clearBtn" style="display:none;">üßπ Clear Room and Nodes</button>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
const map = L.map('map', {
  center: [36.709639, 3.164972],
  zoom: 19,
  maxZoom: 22,
  minZoom: 2
});
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap & CartoDB',
  maxZoom: 22
}).addTo(map);

const refLat = 36.709639;
const refLon = 3.164972;
const meterToDegLat = 1 / 111320;
let drawnShape = null;
let redNodes = [];
const nodeLayer = L.layerGroup().addTo(map);
const gridLayer = L.layerGroup().addTo(map);
const drawnItems = new L.FeatureGroup().addTo(map);
const distanceLayer = L.layerGroup().addTo(map);

function getMeterToDegLon(lat) {
  return 1 / (111320 * Math.cos(lat * Math.PI / 180));
}

function drawGrid() {
  gridLayer.clearLayers();
  if (map.getZoom() < 18) return;

  const bounds = map.getBounds();
  const spacingLat = 2 * meterToDegLat;
  const spacingLon = 2.5 * getMeterToDegLon(map.getCenter().lat);
  const latMin = bounds.getSouth();
  const latMax = bounds.getNorth();
  const lonMin = bounds.getWest();
  const lonMax = bounds.getEast();

  for (let lat = refLat; lat < latMax; lat += spacingLat)
    if (lat > latMin) gridLayer.addLayer(L.polyline([[lat, lonMin], [lat, lonMax]], {color: '#00ff00', weight: 0.5}));
  for (let lat = refLat; lat > latMin; lat -= spacingLat)
    if (lat < latMax) gridLayer.addLayer(L.polyline([[lat, lonMin], [lat, lonMax]], {color: '#00ff00', weight: 0.5}));
  for (let lon = refLon; lon < lonMax; lon += spacingLon)
    if (lon > lonMin) gridLayer.addLayer(L.polyline([[latMin, lon], [latMax, lon]], {color: '#00ff00', weight: 0.5}));
  for (let lon = refLon; lon > lonMin; lon -= spacingLon)
    if (lon < lonMax) gridLayer.addLayer(L.polyline([[latMin, lon], [latMax, lon]], {color: '#00ff00', weight: 0.5}));
}
map.on('moveend zoomend', drawGrid);
drawGrid();

function askLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      map.setView([pos.coords.latitude, pos.coords.longitude], 20);
    }, err => alert("Geolocation error: " + err.message), {enableHighAccuracy: true});
  }
}

const drawControl = new L.Control.Draw({
  draw: {
    polygon: {
      allowIntersection: false,
      showArea: true
    },
    polyline: false,
    rectangle: false,
    circle: false,
    marker: false,
    circlemarker: false
  },
  edit: {
    featureGroup: drawnItems,
    remove: true
  }
});
map.addControl(drawControl);

function startDrawing() {
  document.querySelector('#showBtn').style.display = 'none';
  document.querySelector('#clearBtn').style.display = 'none';
}

map.on('draw:created', function (e) {
  if (drawnShape) {
    drawnItems.clearLayers();
    nodeLayer.clearLayers();
    distanceLayer.clearLayers();
    redNodes = [];
  }

  drawnShape = e.layer;
  drawnItems.addLayer(drawnShape);
  document.querySelector('#showBtn').style.display = 'inline';
  document.querySelector('#clearBtn').style.display = 'inline';
});

function showIntersections() {
  if (!drawnShape) return;

  nodeLayer.clearLayers();
  distanceLayer.clearLayers();
  redNodes = [];

  const shape = drawnShape.getLatLngs()[0];
  const bounds = drawnShape.getBounds();
  const spacingLat = 2 * meterToDegLat;
  const spacingLon = 2.5 * getMeterToDegLon(map.getCenter().lat);

  for (let lat = bounds.getSouth(); lat <= bounds.getNorth(); lat += spacingLat) {
    for (let lon = bounds.getWest(); lon <= bounds.getEast(); lon += spacingLon) {
      const point = L.latLng(lat, lon);
      if (pointInsidePolygon(point, shape)) {
        const red = L.circleMarker(point, {
          color: 'red',
          fillColor: 'red',
          radius: 5,
          fillOpacity: 1
        }).addTo(nodeLayer);

        red.on('click', () => {
          distanceLayer.clearLayers();
          drawDistancesToEdges(point, shape);
        });

        redNodes.push(red);
      }
    }
  }
}

function pointInsidePolygon(point, vs) {
  let x = point.lat, y = point.lng;
  let inside = false;
  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    const xi = vs[i].lat, yi = vs[i].lng;
    const xj = vs[j].lat, yj = vs[j].lng;

    const intersect = ((yi > y) !== (yj > y)) &&
                      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function drawDistancesToEdges(point, polygon) {
  for (let i = 0; i < polygon.length; i++) {
    const a = polygon[i];
    const b = polygon[(i + 1) % polygon.length];
    const closest = getClosestPointOnSegment(point, a, b);

    if (closest) {
      L.polyline([point, closest], { color: 'blue', weight: 1 }).addTo(distanceLayer);
      const meters = map.distance(point, closest).toFixed(2);
      L.marker(closest, {
        icon: L.divIcon({
          className: 'label',
          html: `<div style="background:white;padding:2px 4px;border-radius:4px;border:1px solid gray;">${meters} m</div>`
        })
      }).addTo(distanceLayer);
    }
  }
}

function getClosestPointOnSegment(p, a, b) {
  const latLngToXY = ll => {
    const latRad = ll.lat * Math.PI / 180;
    return {
      x: ll.lng * 40075000 * Math.cos(latRad) / 360,
      y: ll.lat * 111320
    };
  };

  const pa = latLngToXY(a);
  const pb = latLngToXY(b);
  const pp = latLngToXY(p);

  const dx = pb.x - pa.x;
  const dy = pb.y - pa.y;
  const lengthSq = dx * dx + dy * dy;

  const t = ((pp.x - pa.x) * dx + (pp.y - pa.y) * dy) / lengthSq;

  if (t >= 0 && t <= 1) {
    const projX = pa.x + t * dx;
    const projY = pa.y + t * dy;

    const lng = projX / (40075000 * Math.cos(p.lat * Math.PI / 180) / 360);
    const lat = projY / 111320;
    return L.latLng(lat, lng);
  } else {
    return null;
  }
}

function clearRoom() {
  drawnItems.clearLayers();
  nodeLayer.clearLayers();
  distanceLayer.clearLayers();
  drawnShape = null;
  redNodes = [];
  document.querySelector('#showBtn').style.display = 'none';
  document.querySelector('#clearBtn').style.display = 'none';
}
</script>
</body>
</html>
