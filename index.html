<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hartmann Grid Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    #controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    /* Style for buttons */
    button {
      padding: 6px 12px;
      font-size: 14px;
      margin: 4px;
      border-radius: 5px;
      background-color: #ffffff;
      color: #555;
      border: 1px solid #ddd;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }

    /* Hover effect */
    button:hover {
      background-color: #f1f1f1;
      border-color: #555;
    }

    /* Active effect */
    button:active {
      background-color: #e6e6e6;
      border-color: #555;
    }

    /* Tutorial modal styles */
    .tutorial-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5); /* Black background with transparency */
    }

    .tutorial-content {
      background-color: white;
      margin: 15% auto;
      padding: 20px;
      border-radius: 10px;
      width: 80%;
      max-width: 500px;
    }

    .close-btn {
      color: black;
      font-size: 30px;
      font-weight: bold;
      position: absolute;
      top: 10px;
      right: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="controls">
  <button onclick="askLocation()"><i class="fas fa-map-marker-alt"></i> Locate</button>
  <button onclick="showIntersections()" id="showBtn" style="display:none;"><i class="fas fa-eye"></i> Show Intersections</button>
  <button onclick="clearRoom()" id="clearBtn" style="display:none;"><i class="fas fa-eraser"></i> Clear</button>
</div>
<div id="map"></div>

<!-- Tutorial Modal -->
<div class="tutorial-modal" id="tutorialModal">
  <div class="tutorial-content">
    <span class="close-btn" onclick="closeTutorial()">&times;</span>
    <h2>Welcome to Hartmann Grid Tracker!</h2>
    <p>Follow the steps below to start using the app:</p>
    <ol>
      <li>Click the <strong>Locate</strong> button to find your location on the map.</li>
      <li>Draw a polygon on the map to define a room.</li>
      <li>Click the <strong>Show Intersections</strong> button to display the Hartmann grid intersections within the room.</li>
      <li>Click on an intersection to measure the distances to the room edges.</li>
      <li>Click the <strong>Clear</strong> button to reset the drawing and start over.</li>
    </ol>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
const map = L.map('map', {
  center: [36.709639, 3.164972],
  zoom: 19,
  maxZoom: 22,
  minZoom: 2
});

L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap & CartoDB',
  maxZoom: 22
}).addTo(map);

const refLat = 36.709639;
const refLon = 3.164972;
const meterToDegLat = 1 / 111320;

function getMeterToDegLon(lat) {
  return 1 / (111320 * Math.cos(lat * Math.PI / 180));
}

let drawnShape = null;
const redNodes = [];
const nodeLayer = L.layerGroup().addTo(map);
const gridLayer = L.layerGroup().addTo(map);
const drawnItems = new L.FeatureGroup().addTo(map);
const distanceLayer = L.layerGroup().addTo(map);

function drawGrid() {
  const bounds = map.getBounds();
  const spacingLat = 2 * meterToDegLat;
  const spacingLon = 2.5 * getMeterToDegLon(map.getCenter().lat);
  const latMin = bounds.getSouth();
  const latMax = bounds.getNorth();
  const lonMin = bounds.getWest();
  const lonMax = bounds.getEast();

  gridLayer.clearLayers();
  if (map.getZoom() < 20) return;

  let startLat = refLat;
  while (startLat > latMin) startLat -= spacingLat;
  let startLon = refLon;
  while (startLon > lonMin) startLon -= spacingLon;

  for (let lat = startLat; lat <= latMax; lat += spacingLat) {
    gridLayer.addLayer(L.polyline([[lat, lonMin], [lat, lonMax]], {color: '#00ff00', weight: 0.5}));
  }
  for (let lon = startLon; lon <= lonMax; lon += spacingLon) {
    gridLayer.addLayer(L.polyline([[latMin, lon], [latMax, lon]], {color: '#00ff00', weight: 0.5}));
  }
}
map.on('moveend zoomend', drawGrid);
drawGrid();

function askLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      map.setView([pos.coords.latitude, pos.coords.longitude], 20);
    }, err => alert("Geolocation error: " + err.message), {enableHighAccuracy: true});
  } else {
    alert("Geolocation is not supported by this browser.");
  }
}

const drawControl = new L.Control.Draw({
  draw: {
    polygon: { allowIntersection: false, showArea: true },
    polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false
  },
  edit: { featureGroup: drawnItems, remove: true }
});
map.addControl(drawControl);

function startDrawing() {
  document.querySelector('#showBtn').style.display = 'none';
  document.querySelector('#clearBtn').style.display = 'none';
}

map.on('draw:created', function (e) {
  if (drawnShape) {
    drawnItems.clearLayers();
    nodeLayer.clearLayers();
    distanceLayer.clearLayers();
  }
  drawnShape = e.layer;
  drawnItems.addLayer(drawnShape);
  document.querySelector('#showBtn').style.display = 'inline';
  document.querySelector('#clearBtn').style.display = 'inline';
});

function pointInsidePolygon(point, polygon) {
  let inside = false;
  let x = point.lat, y = point.lng;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lat, yi = polygon[i].lng;
    const xj = polygon[j].lat, yj = polygon[j].lng;
    const intersect = ((yi > y) !== (yj > y)) &&
                      (x < (xj - xi) * (y - yi) / (yj - yi + 0.00000001) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function showIntersections() {
  if (!drawnShape || map.getZoom() < 19) {
    alert("Zoom in further to view intersections.");
    return;
  }

  const polygon = drawnShape.getLatLngs()[0];
  gridLayer.getLayers().forEach(line => {
    line.getLatLngs().forEach((latlng, idx) => {
      if (pointInsidePolygon(latlng, polygon)) {
        nodeLayer.addLayer(L.circle(latlng, { radius: 1, color: 'red' }));
      }
    });
  });
}

function clearRoom() {
  drawnItems.clearLayers();
  nodeLayer.clearLayers();
  distanceLayer.clearLayers();
  document.querySelector('#showBtn').style.display = 'none';
  document.querySelector('#clearBtn').style.display = 'none';
}

function closeTutorial() {
  document.getElementById('tutorialModal').style.display = 'none';
}

// Show tutorial modal on page load
window.onload = () => {
  document.getElementById('tutorialModal').style.display = 'block';
};
</script>
</body>
</html>
